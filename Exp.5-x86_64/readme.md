# Limc

Limc Is a Minimal Compiler

## 目标代码生成 `x86-64`

### `x86-64`寄存器描述

`x86-64`拥有16个64位寄存器：

- `RAX`
- `RBX`
- `RCX`
- `RDX`
- `RDI`
- `RSI`
- `RBP`
- `RSP`
- `R8-15`

如何使用：

首先将寄存器分为四类：

- 用于保存中间结果
- 用于传递参数
- 用于各种通用计算
- 栈帧、跳转相关

由于想要利用C语言的ABI，因此参数传递必须遵守C语言的标准，实验如下：

```c++
void fn(int a, int b, int c, int d, int e, int f, int g) { return; }

int main() {
    fn(0, 0, 0, 0, 0, 0, 0);
    return 0;
}
```

生成GAS代码：

`$ gcc -S -masm=intel a.c`

```asm

...

	mov	dword ptr [rbp - 4], edi
	mov	dword ptr [rbp - 8], esi
	mov	dword ptr [rbp - 12], edx
	mov	dword ptr [rbp - 16], ecx
	mov	dword ptr [rbp - 20], r8d
	mov	dword ptr [rbp - 24], r9d
	mov	dword ptr [rbp - 28], eax ## 4-byte Spill

...

_main:   

...

	mov	edi, eax
	mov	esi, eax
	mov	edx, eax
	mov	ecx, eax
	mov	r8d, eax
	mov	r9d, eax
	mov	dword ptr [rsp], 0
	call	_fn

...

```

可见对于前六个参数依次使用了`edi`, `esi`, `edx`, `ecx`, `r8d`, `r9d`

再进行实验

```c++
void fn() { printf("a", 2, 3, 4, 5, 6); }
```

有

```asm
...

	.cfi_def_cfa_register rbp
	sub	rsp, 16
	lea	rdi, [rip + L_.str]
	mov	esi, 2
	mov	edx, 3
	mov	ecx, 4
	mov	r8d, 5
	mov	r9d, 6
	mov	al, 0
	call	_printf

...

```

则使用了`rdi`, `esi`, `edx`, `ecx`, `r8d`, `r9d`

若`void fn() { printf("1", "2", "3", "4", "5", "6"); }`则有

```
	sub	rsp, 16
	lea	rdi, [rip + L_.str]
	lea	rsi, [rip + L_.str.1]
	lea	rdx, [rip + L_.str.2]
	lea	rcx, [rip + L_.str.3]
	lea	r8, [rip + L_.str.4]
	lea	r9, [rip + L_.str.5]
	mov	al, 0
```

比较可见，这三次都是在使用`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`的整体或一部分，因此此次试验我也打算这样使用参数寄存器

也可以通过`syscall`证明[https://wiki.cdot.senecacollege.ca/wiki/Syscalls#x86_64-bit](https://wiki.cdot.senecacollege.ca/wiki/Syscalls#x86_64-bit)

此外，随意使用的寄存器或函数返回值存储根据国际惯例设定为`RAX`，栈顶寄存器和基址寄存器也按照规定使用`RSP`与`RBP`，其余都用作中间变量寄存器。

因此，总结一下：

|  REG   |      USE      |
| :----: | :-----------: |
|  rax   |    General    |
|  rbp   | Base Pointer  |
|  rsp   | Stack Pointer |
|  rdi   |    arg[1]     |
|  rsi   |    arg[2]     |
|  rdx   |    arg[3]     |
|  rcx   |    arg[4]     |
|   r8   |    arg[5]     |
|   r9   |    arg[6]     |
|  rbx   |  Tmp Res[1]   |
| r10-15 | Tmp Res[2-7]  |

重要：r10与r11无法跨调用保存，因此要在call之前压入栈

六个参数寄存器，七个中间结果寄存器

根据中间代码生成思想：

> 中间运算结果的生命周期很短，且单独一个表达式不会涉及很多寄存器

我认为七个寄存器已经够用了


### 栈帧（活动记录）设计

前提：

- 栈从高地址向低地址增长
- 因此当进入一个函数时
    - 首先push主调函数的rbp（原基址）[C]
    - 然后将主调函数的rsp送给rbp，作为被调函数的rbp [B]
    - 然后，将此时的rsp减去被调函数的本地栈大小
        - 这里是为了被调函数调用其他函数而准备
        - 除了call，其他指令不涉及与rsp的交互
    - push所有主调相关寄存器 [A]
- 【开始被调函数】
- 结束时
    - pop刚才保存的所有主调相关寄存器 [A]
    - 将此时的rbp送回rsp，恢复主调函数的rsp [B]
    - pop主调函数的rbp [C]
    - ret结束过程
- 内存并没有精确对齐，因为x86-64不强求

使用函数调用的全过程说明栈帧的开辟与销毁：

1. 平凡状态（任何状态）

|         地址         | 寄存器 |  含义  |
| :------------------: | :----: | :----: |
| **-------高-------** |        |        |
|                      |  ...   |        |
|         rsp          |        | 原栈顶 |
| **-------低-------** |        |        |

2. 调用函数

- 先将各种参数移入对应长度的寄存器`mov ARG_REG[x], REG[x]`
- 压入不能跨call保存的寄存器r10与r11
- 置返回值寄存器rax=0
- 调用函数
- (...函数返回回来)
- 弹出保存的r10与r11
- 将返回值寄存器rax送入设定好的临时寄存器`mov REG[x], rax`

a. 从主调函数进入被调函数

|                                  地址 | 存储的寄存器/保存的内容 | 含义/其他动作                                    |
| ------------------------------------: | :---------------------: | :----------------------------------------------- |
|                  **-------高-------** |                         |                                                  |
|                                       |           ...           |                                                  |
|                                   rsp |                         | 原栈顶                                           |
|                                   rsp |           r10           | 保存的r10                                        |
|                                   rsp |           r11           | 保存的r11                                        |
|                                   rsp |         rip<原>         | `call`保存主调函数的rip，然后跳转到目标label     |
|                 rsp<执行前> / **rbp** |           rbp           | 原基址                                           |
|                                       |                         | ...进入目标函数后，置rbp:=rsp<当前>              |
|                                       |                         | 然后rsp<扩展> = rsp<执行前>-(本地栈大小 对齐 16) |
|                   rbp-参数1的本地偏移 |     参数1 (1\|4\|8)     | 保存函数参数指令  （mov 内存，寄存器）           |
|                   rbp-参数2的本地偏移 |     参数2 (1\|4\|8)     | 保存函数参数指令                                 |
|                                       |           ...           |                                                  |
|               \[rbp-参数6的本地偏移\] |   \[参数6 (1\|4\|8)\]   | 保存函数参数指令                                 |
|             rbp-某局部变量x的本地偏移 |                         | 局部变量x                                        |
|                                   ... |                         | ...                                              |
| rbp-某局部变量y的本地偏移 / rsp<扩展> |                         | 局部变量                                         |
|                                       |           r12           | `push r12`                                       |
|                                       |           r13           | `push r13`                                       |
|                                       |           r14           | `push r14`                                       |
|                          rsp\<FINAL\> |           r15           | `push r15`(**栈顶**)                             |
|                  **-------低-------** |                         |                                                  |


b. 函数执行结束

- 执行本地收尾
  - 弹出r15
  - 弹出r14
  - 弹出r13
  - 弹出r12
  - **rsp被赋为rbp**，因此本地栈的临时变量被隐式销毁

|                    地址 | 存储的寄存器/保存的内容 | 含义/其他动作                                |
| ----------------------: | :---------------------: | :------------------------------------------- |
|    **-------高-------** |                         |                                              |
|                         |           ...           |                                              |
|                     rsp |                         | 原栈顶                                       |
|                     rsp |           r10           | 保存的r10                                    |
|                     rsp |           r11           | 保存的r11                                    |
|                     rsp |         rip<原>         | `call`保存主调函数的rip，然后跳转到目标label |
| rsp<又回来了> / **rbp** |           rbp           | `mov rsp, rbp`                               |
|    **-------低-------** |                         |                                              |

- `pop rbp`，恢复主调函数的基址
- `ret`，使用`rip`回到调用点

|                 地址 | 存储的寄存器/保存的内容 | 含义/其他动作 |
| -------------------: | :---------------------: | :------------ |
| **-------高-------** |                         |               |
|                      |           ...           |               |
|                  rsp |                         | 原栈顶        |
|                  rsp |           r10           | 保存的r10     |
|                  rsp |           r11           | 保存的r11     |
| **-------低-------** |                         |               |


- 执行主调方收尾
  - `pop r11`
  - `pop r10`
  - 获取rax中的返回值（如果有）（没有也无所谓，因为没人会用）

- 一切结束

|                 地址 | 存储的寄存器/保存的内容 | 含义/其他动作 |
| -------------------: | :---------------------: | :------------ |
| **-------高-------** |                         |               |
|                      |           ...           |               |
|                  rsp |                         | 原栈顶        |
| **-------低-------** |                         |               |


综上所述，栈帧布局如下

|                       地址 |    内容     |
| -------------------------: | :---------: |
|       **-------高-------** |             |
|                            |     ...     |
|                  rsp<原来> |             |
|                            |     r10     |
|                            |     r11     |
|                            | rip\<原来\> |
| rsp<执行前> 也是 rbp<现在> | rbp\<原来\> |
|                            |    参数1    |
|                            |     ...     |
|                            |  \[参数6\]  |
|                            |  局部变量   |
|                            |     ...     |
|                  rsp<扩展> |  局部变量   |
|                            |     r12     |
|                            |     r13     |
|                            |     r14     |
|               rsp\<FINAL\> |     r15     |
|       **-------低-------** |             |

参数与局部变量用`[rbp-局部偏移]`指明

注意，偏移指的是变量的末尾（最低字节）相对于rbp的距离，不是高字节

```asm
lea reg, [rbp-局部偏移]
mov reg, [reg] ## 长度通过寄存器指出
```
